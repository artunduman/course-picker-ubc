import itertools


class CourseSelector:
    @staticmethod
    def _product_dict(**kwargs):
        keys = kwargs.keys()
        vals = list(kwargs.values())
        for instance in itertools.product(*vals):
            yield dict(zip(keys, instance))

    def select_by_average_without_overlap(self, course_info, number_of_sections_to_select):
        """
        At beta, brute forces all non-overlapping combinations and
        returns the best selection of courses in terms of averages of profs
        :param course_info:
        Can be generated by courses_manager
        {
            'CPSC310': {
                '101': {
                    'start': '12:30',
                    'end': '14:00',
                    'days': 'Tue Thu',
                    'prof': 'john-doe',
                }
            }
        }
        :param number_of_sections_to_select:
        How many of these sections/courses I want to pick
        :return:
        List of selected courses and sections
        """
        combined_list = list(map(dict, itertools.combinations(course_info.items(), number_of_sections_to_select)))
        # This combination doesn't determine the sections, just the courses [CPSC221: {}, CPSC213: {}] etc.
        for combination in combined_list:
            product = self._product_dict(**combination)
            # TODO left here!
